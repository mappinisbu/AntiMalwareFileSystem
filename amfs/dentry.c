/*
 * Copyright (c) 1998-2014 Erez Zadok
 * Copyright (c) 2009	   Shrikar Archak
 * Copyright (c) 2003-2014 Stony Brook University
 * Copyright (c) 2003-2014 The Research Foundation of SUNY
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include "amfs.h"

/*
 * returns: -ERRNO if error (returned to user)
 *          0: tell VFS to invalidate dentry
 *          1: dentry is valid
 */
static int amfs_d_revalidate(struct dentry *dentry, unsigned int flags)
{
	struct path lower_path;
	struct dentry *lower_dentry;
	int err = 1;

	if (flags & LOOKUP_RCU)
		return -ECHILD;

	amfs_get_lower_path(dentry, &lower_path);
	lower_dentry = lower_path.dentry;
    // if lower dentry is not null and has malfile attribute set, call revalidate everytime

    if(lower_dentry != NULL)
    {
        char val[2];
        const char* name = "user.malfile";
        memset(val, 0, 2);
        int xattr_size = vfs_getxattr(lower_dentry, name, val, 1);
        if(xattr_size == 1 && val[0] == '1')
        {
           printk(" bad file and xattr size in revalidate: %d, %s\n",xattr_size, val);
           err = 0;
           goto out;
        }

    }    

	if (!(lower_dentry->d_flags & DCACHE_OP_REVALIDATE))
		goto out;

	err = lower_dentry->d_op->d_revalidate(lower_dentry, flags);
out:
	amfs_put_lower_path(dentry, &lower_path);
	return err;
}

static void amfs_d_release(struct dentry *dentry)
{
	/* release and reset the lower paths */
	amfs_put_reset_lower_path(dentry);
	free_dentry_private_data(dentry);
	return;
}

const struct dentry_operations amfs_dops = {
	.d_revalidate	= amfs_d_revalidate,
	.d_release	= amfs_d_release,
};
