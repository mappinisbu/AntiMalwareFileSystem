/*
 * Copyright (c) 1998-2014 Erez Zadok
 * Copyright (c) 2009	   Shrikar Archak
 * Copyright (c) 2003-2014 Stony Brook University
 * Copyright (c) 2003-2014 The Research Foundation of SUNY
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include "amfs.h"

static ssize_t amfs_read(struct file *file, char __user *buf,
			   size_t count, loff_t *ppos)
{
	int err;
	struct file *lower_file;
	struct dentry *dentry = file->f_path.dentry;

    /* check if the file is bad*/
    char val[2];
    const char* name = "user.malfile";
    memset(val, 0, 2);
    int xattr_size = vfs_getxattr(dentry, name, val, 1);
    if(xattr_size == 1  && val[0] == '1')
    {
       printk(" bad file and xattr size: %d, %s\n",xattr_size, val);
       err = -ENOENT;

       return err;
    }


	lower_file = amfs_lower_file(file);
	err = vfs_read(lower_file, buf, count, ppos);
	/* update our inode atime upon a successful lower read */
   
	if (err >= 0)
		fsstack_copy_attr_atime(dentry->d_inode,
					file_inode(lower_file));

    // err greater than 0 is bytes read

    if( err > 0)
    {
        struct amfs_sb_info* sbi = (struct amfs_sb_info*)(file->f_path.dentry->d_sb->s_fs_info);
        struct my_pattern_list* patthead = sbi->pattern_head;
        struct list_head *pos;
        struct my_pattern_list* tmpPatt;
        bool mal_pat_found = false;
  
        list_for_each(pos, &patthead->list)
        {
            tmpPatt = list_entry(pos, struct my_pattern_list, list);
            int n = err;
            int m = tmpPatt->pattLen;

            int i = 0;
            for( i = 0; i < (n-m+1); i++)
            {

                int k = 0;
                bool isMatch = true;
     
                for(k = 0; k < m; k++)
                {
                   if(buf[i+k] != tmpPatt->pattern[k])
                   {
                        isMatch = false;
                        break;
                   }
                }

                if(isMatch)
                {
                    /* Malware pattern found*/
                    mal_pat_found = true;
                    printk("setting the xattr\n");
                    const char* value = "1";
    
                    int rc = vfs_setxattr(dentry, name, value, 1, XATTR_CREATE);
                    if(rc == 0 )
                        printk("successfully set the attribute in read");

                    // delete the entry from dentry cache
                    //free_dentry_private_data(dentry);

                    break;
                    err = -ENOENT;

                }
           
            }

            if(mal_pat_found)
                break;

        }     
      
    }

	return err;
}

static ssize_t amfs_write(struct file *file, const char __user *buf,
			    size_t count, loff_t *ppos)
{
	int err;

	struct file *lower_file;
	struct dentry *dentry = file->f_path.dentry;

    char val[2];
    const char* name = "user.malfile";
    memset(val, 0, 2);
    int xattr_size = vfs_getxattr(dentry, name, val, 1);
    if(xattr_size == 1 && val[0] == '1')
    {
       printk(" bad file and xattr size: %d, %s\n",xattr_size, val);
       err = -EACCES;
       return err;
    }


	lower_file = amfs_lower_file(file);
	err = vfs_write(lower_file, buf, count, ppos);
	/* update our inode times+sizes upon a successful lower write */
	if (err >= 0) {
		fsstack_copy_inode_size(dentry->d_inode,
					file_inode(lower_file));
		fsstack_copy_attr_times(dentry->d_inode,
					file_inode(lower_file));
	}

     if( err > 0)
    {
        struct amfs_sb_info* sbi = (struct amfs_sb_info*)(file->f_path.dentry->d_sb->s_fs_info);
        struct my_pattern_list* patthead = sbi->pattern_head;
        struct list_head *pos;
        struct my_pattern_list* tmpPatt;
        bool mal_pat_found = false;

        list_for_each(pos, &patthead->list)
        {
            tmpPatt = list_entry(pos, struct my_pattern_list, list);
            int n = err;
            int m = tmpPatt->pattLen;

            int i = 0;
            for( i = 0; i < (n-m+1); i++)
            {

                int k = 0;
                bool isMatch = true;

                for(k = 0; k < m; k++)
                {
                   if(buf[i+k] != tmpPatt->pattern[k])
                   {
                        isMatch = false;
                        break;
                   }
                }

                if(isMatch)
                {
                    mal_pat_found = true;
                    printk("setting the xattr\n");
                    const char* value = "1";

                    int rc = vfs_setxattr(dentry, name, value, 1, XATTR_CREATE);
                    if(rc == 0 )
                        printk("successfully set the attribute in write\n");
                    //free_dentry_private_data(dentry);
                    break;
                 }

             } 

             if(mal_pat_found)
                 break;
            }


       }


	return err;
}



/* inspired from ecryptfs readdir */

struct amfs_getdents_callback {
    struct dir_context ctx;
    struct dir_context *caller;
    struct dentry *lower_dentry;//lower dentry helps to get the dir dentry we are in
    int filldir_called;
    int entries_written;
 };


static int amfs_filldir(struct dir_context *ctx, char *lower_name,int lower_namelen, loff_t offset, u64 ino, unsigned int d_type)
 {
     printk("amfs filldir called\n");
     // pointer arithmatic, get the struct from the ctx
     struct amfs_getdents_callback *buf =  container_of(ctx, struct amfs_getdents_callback, ctx);
     int rc;
 
     buf->filldir_called++;
     buf->caller->pos = buf->ctx.pos;

     struct dentry* lower__dentry = buf->lower_dentry;
     struct dentry* lower_file_dentry = lookup_one_len(lower_name, lower__dentry, lower_namelen);
     const char* dot = ".";
     const char* dotdot = "..";
     printk(" the lower file is: %s\n", lower_name);
     
     if(strcmp(lower_name, dot) == 0)
     {
        printk(" emitting current directory\n");
     }
     else if(strcmp(lower_name, dotdot) == 0)
     {
        printk(" emitting parent dir ..");

     }else if(lower_file_dentry != NULL ) {
     
         char val[2];
         const char* attrname = "user.malfile";
         memset(val, 0, 2);
         int xattr_size = vfs_getxattr(lower_file_dentry, attrname, val, 1);

         if(xattr_size == 1 && val[0] == '1')
         {
            printk(" bad file and xattr size in filldir: %d, %s\n",xattr_size, val);
            lower_namelen = 0;
            lower_name = NULL;
         }
     }


     rc = !dir_emit(buf->caller, lower_name, lower_namelen, ino, d_type);
     if (!rc)
        buf->entries_written++;

     return rc;
  }

/* inspired from ecrypts readdir */

static int amfs_readdir(struct file *file, struct dir_context *ctx)
{
    
    printk(" read dir called\n");
	int err;
	struct file *lower_file = NULL;
	struct dentry *dentry = file->f_path.dentry;
    lower_file = amfs_lower_file(file);

    struct amfs_getdents_callback buf = {
        .ctx.actor = (filldir_t)amfs_filldir,
        .caller = ctx,
        .lower_dentry = lower_file->f_path.dentry,
    };

    lower_file->f_pos = ctx->pos;
	err = iterate_dir(lower_file, &buf.ctx);
    ctx->pos = buf.ctx.pos;
    file->f_pos = ctx->pos;

    if (err < 0)
        goto out;
    if (buf.filldir_called && !buf.entries_written)
        goto out;
	if (err >= 0)		/* copy the atime */
		fsstack_copy_attr_atime(dentry->d_inode, file_inode(lower_file));

out:
	return err;
}

static long amfs_unlocked_ioctl(struct file *file, unsigned int cmd,
				  unsigned long arg)
{
	long err = -ENOTTY;
	struct file *lower_file;
    
    printk("ioctl method called \n");

    struct amfs_sb_info* sbi = (struct amfs_sb_info*)(file->f_path.dentry->d_sb->s_fs_info);
    bool isModify = false;

    printk(" after getting sbi\n");
    struct list_head *pos;
    struct my_pattern_list* tmpPatt;
    struct my_pattern_list* patthead = sbi->pattern_head;
    list_for_each(pos, &patthead->list)
    {
       tmpPatt = list_entry(pos, struct my_pattern_list, list);
       int i = 0;
       for(i=0; i < tmpPatt->pattLen; i++)
       {
           printk("%c", tmpPatt->pattern[i]);
       }
       printk("\n");
    }

    printk(" pattern file: %s\n",  sbi->patternFileName);
 
    if(AMFS_IOCADD == cmd)
    {
        // add to list, allows duplicates
        if((char*)arg == NULL)
        {
            err = -EINVAL;
            goto out;
        }

        char* pat = (char*)arg;
        int patlen = strlen_user(pat);// assumed to not contain nulls as given from command line
        char* kpat = (char*) kmalloc(patlen, GFP_KERNEL);
        if(!kpat)
        {
            err = -ENOMEM;
            goto out;
        }
        memset(kpat, 0, patlen);
        err = copy_from_user(kpat, pat, patlen);
        if(err < 0)
        {
           kfree(kpat);
           goto out;
        }
        printk("patt to add : %s whose length is %d\n",kpat, patlen-1); 
        tmpPatt = (struct my_pattern_list*)kmalloc(sizeof(struct my_pattern_list),GFP_KERNEL);
        if(!tmpPatt)
        {
           err = -ENOMEM;
           kfree(kpat);
           goto out;
        }
        tmpPatt->pattern = kpat;
        tmpPatt->pattLen = patlen-1;// -1 for the null character
        INIT_LIST_HEAD(&tmpPatt->list);
        list_add(&tmpPatt->list, &patthead->list);
        printk("added address : %p", &tmpPatt->list);

        // print
      
        list_for_each(pos, &patthead->list)
        {
          tmpPatt = list_entry(pos, struct my_pattern_list, list);
          int i = 0;
          for(i=0; i < tmpPatt->pattLen; i++)
          {
              printk("%c", tmpPatt->pattern[i]);
          }
          printk("\n");
        }
        err = 0; // success
        isModify = true;
    }
   else if (AMFS_IOCREM == cmd)
    {
        // remove pattern
        bool patRemFound = false;
        if((char*)arg == NULL)
        {
            err = -EINVAL;
            goto out;
        }
        char* pat = (char*)arg;
        int patlen = strlen_user(pat);
        char* kpat = (char*) kmalloc(patlen, GFP_KERNEL);
        if(!kpat)
        {
            err = -ENOMEM;
            goto out;
        }

        memset(kpat, 0, patlen);
        err = copy_from_user(kpat, pat, patlen);
        if(err < 0)
        {
           kfree(kpat);
           goto out;
        }

        struct list_head *q;
        patlen  = patlen - 1;
        // removes duplicates
        list_for_each_safe(pos,q, &patthead->list)
        {
            tmpPatt = list_entry(pos, struct my_pattern_list, list);
            int i = 0;
            if(tmpPatt->pattLen == patlen)
            {
                bool isequal = true;
                for(i=0; i < tmpPatt->pattLen; i++)
                {
                    if(tmpPatt->pattern[i] != kpat[i])
                       isequal = false;
                }
              
                if(isequal)
                {
                   patRemFound = true;
                   printk("deleting elem : %s\n", tmpPatt->pattern);
                   printk("deleting address : %p", &tmpPatt->list);
                   list_del(pos);
                   kfree(tmpPatt);
                } 
            }
         }

         printk(" after deletion \n");
         list_for_each(pos, &patthead->list)
         {
             tmpPatt = list_entry(pos, struct my_pattern_list, list);
             int i = 0;
             for(i=0; i < tmpPatt->pattLen; i++)
             {
                 printk("%c", tmpPatt->pattern[i]);
             }
             printk("\n");
         }

      if(patRemFound)
      {
          err = 0; // success
          isModify = true;
      }
      else
          err = -EINVAL;

    }
    else if(AMFS_IOCLISTLEN == cmd)
    {
       // list pattern
       int totalPatSize = 0;
       list_for_each(pos, &patthead->list)
         {
             tmpPatt = list_entry(pos, struct my_pattern_list, list);
             totalPatSize = totalPatSize + tmpPatt->pattLen;
             totalPatSize = totalPatSize + 1 ;// for new line             
         }

        printk(" total patterns buffer size: %d", totalPatSize);
        err = copy_to_user((int *)arg, &totalPatSize, 4); // 4 coz of 32 bit 4*8       
         // success
    }
    else if(AMFS_IOCLIST == cmd)
    {
        if((char*)arg == NULL)
        {
            err = -EINVAL;
            goto out;
        }

       int totalPatSize = 0;
       list_for_each(pos, &patthead->list)
       {
           tmpPatt = list_entry(pos, struct my_pattern_list, list);
           totalPatSize = totalPatSize + tmpPatt->pattLen;
           totalPatSize = totalPatSize + 1 ;// for new line
       }
        
       char* patterns = (char*) kmalloc(totalPatSize, GFP_KERNEL);
       if(!patterns)
       {
           err = -ENOMEM;
           goto out;
       }
       int l = 0;
      
       list_for_each(pos, &patthead->list)
       {
             tmpPatt = list_entry(pos, struct my_pattern_list, list);
             int k = 0;
             for( k =0; k < tmpPatt->pattLen; k++)
             {
                 patterns[l] = tmpPatt->pattern[k];
                 l++;
             }
             patterns[l] = '\n';
             l++;
       }

       err = copy_to_user((char*)arg, patterns, totalPatSize);
       kfree(patterns); // free patterns

    }else
    {
        // call the lower file system ioctl. not defined in amfs layer
        lower_file = amfs_lower_file(file);
        /* XXX: use vfs_ioctl if/when VFS exports it */
        if (!lower_file || !lower_file->f_op)
            goto out;
        if (lower_file->f_op->unlocked_ioctl)
            err = lower_file->f_op->unlocked_ioctl(lower_file, cmd, arg);

        /* some ioctls can change inode attributes (EXT2_IOC_SETFLAGS) */
        if (!err)
            fsstack_copy_attr_all(file_inode(file),
                      file_inode(lower_file));

   
    }

    if(isModify) {
        // pattern has been added or removed, so write to file
        struct file *inifilp = NULL;
        struct file *filp = NULL;
  
        inifilp = filp_open(sbi->patternFileName,O_RDONLY, 0);    
        if (!inifilp || IS_ERR(inifilp))
        {
            printk("cannot open pattern file, continuing....\n");
            goto out;
        }

        umode_t inMode = inifilp->f_path.dentry->d_inode->i_mode;

        char* tempPattern = (char*) kmalloc(strlen(sbi->patternFileName) + 5, GFP_KERNEL);
        if(!tempPattern)
        {
            printk(" unable to create pattern file path memory, continuing...\n");
            filp_close(inifilp, NULL);
            goto out;
        }
        memset(tempPattern, 0, strlen(sbi->patternFileName) + 5);
        strcat(tempPattern, sbi->patternFileName);
        strcat(tempPattern, ".tmp");

        filp = filp_open(tempPattern,  O_WRONLY|O_CREAT, inMode);
        if (!filp || IS_ERR(filp))
        {
            printk("unable to open the temp pattern file, continuing\n");
            filp_close(inifilp, NULL);
            kfree(tempPattern);
            goto out;
        }  

        filp->f_pos = 0;
        char newline[2];
        memset(newline, 0, 2);
        newline[0] = '\n';
        size_t nl = 1;

        list_for_each(pos, &patthead->list)
        {
           tmpPatt = list_entry(pos, struct my_pattern_list, list);
           filp->f_op->write(filp, tmpPatt->pattern, tmpPatt->pattLen, &(filp->f_pos));
           filp->f_op->write(filp, newline, nl, &(filp->f_pos));
        }

        struct inode* old_file = filp->f_path.dentry->d_parent->d_inode;
        struct dentry* old_dentry = filp->f_path.dentry;
        struct inode* new_file = inifilp->f_path.dentry->d_parent->d_inode;
        struct dentry* new_dentry =  inifilp->f_path.dentry;

        filp_close(inifilp, NULL);
        filp_close(filp, NULL);
        kfree(tempPattern);

        if(vfs_rename(old_file, old_dentry, new_file, new_dentry, NULL, 0) < 0)
        {
            printk(" renaming failed, continuing\n");
        }
    }


out:
	return err;
}

#ifdef CONFIG_COMPAT
static long amfs_compat_ioctl(struct file *file, unsigned int cmd,
				unsigned long arg)
{
	long err = -ENOTTY;
	struct file *lower_file;

	lower_file = amfs_lower_file(file);

	/* XXX: use vfs_ioctl if/when VFS exports it */
	if (!lower_file || !lower_file->f_op)
		goto out;
	if (lower_file->f_op->compat_ioctl)
		err = lower_file->f_op->compat_ioctl(lower_file, cmd, arg);

out:
	return err;
}
#endif

static int amfs_mmap(struct file *file, struct vm_area_struct *vma)
{
	int err = 0;
	bool willwrite;
	struct file *lower_file;
	const struct vm_operations_struct *saved_vm_ops = NULL;

	/* this might be deferred to mmap's writepage */
	willwrite = ((vma->vm_flags | VM_SHARED | VM_WRITE) == vma->vm_flags);

	/*
	 * File systems which do not implement ->writepage may use
	 * generic_file_readonly_mmap as their ->mmap op.  If you call
	 * generic_file_readonly_mmap with VM_WRITE, you'd get an -EINVAL.
	 * But we cannot call the lower ->mmap op, so we can't tell that
	 * writeable mappings won't work.  Therefore, our only choice is to
	 * check if the lower file system supports the ->writepage, and if
	 * not, return EINVAL (the same error that
	 * generic_file_readonly_mmap returns in that case).
	 */
	lower_file = amfs_lower_file(file);
	if (willwrite && !lower_file->f_mapping->a_ops->writepage) {
		err = -EINVAL;
		printk(KERN_ERR "amfs: lower file system does not "
		       "support writeable mmap\n");
		goto out;
	}

	/*
	 * find and save lower vm_ops.
	 *
	 * XXX: the VFS should have a cleaner way of finding the lower vm_ops
	 */
	if (!AMFS_F(file)->lower_vm_ops) {
		err = lower_file->f_op->mmap(lower_file, vma);
		if (err) {
			printk(KERN_ERR "amfs: lower mmap failed %d\n", err);
			goto out;
		}
		saved_vm_ops = vma->vm_ops; /* save: came from lower ->mmap */
	}

	/*
	 * Next 3 lines are all I need from generic_file_mmap.  I definitely
	 * don't want its test for ->readpage which returns -ENOEXEC.
	 */
	file_accessed(file);
	vma->vm_ops = &amfs_vm_ops;

	file->f_mapping->a_ops = &amfs_aops; /* set our aops */
	if (!AMFS_F(file)->lower_vm_ops) /* save for our ->fault */
		AMFS_F(file)->lower_vm_ops = saved_vm_ops;

out:
	return err;
}

static int amfs_open(struct inode *inode, struct file *file)
{
	int err = 0;
	struct file *lower_file = NULL;
	struct path lower_path;


    printk(" file open in amfs\n");

	/* don't open unhashed/deleted files */
	if (d_unhashed(file->f_path.dentry)) {
		err = -ENOENT;
		goto out_err;
	}

    char val[2];
    const char* name = "user.malfile";
    memset(val, 0, 2);
    int xattr_size = vfs_getxattr(file->f_path.dentry, name, val, 1);
    if(xattr_size == 1  && val[0] == '1')
    {
       printk(" bad file and xattr size: %d, %s\n",xattr_size, val);
       err = -ENOENT;
       goto out_err;
    }


	file->private_data =
		kzalloc(sizeof(struct amfs_file_info), GFP_KERNEL);
	if (!AMFS_F(file)) {
		err = -ENOMEM;
		goto out_err;
	}

	/* open lower object and link amfs's file struct to lower's */
	amfs_get_lower_path(file->f_path.dentry, &lower_path);
	lower_file = dentry_open(&lower_path, file->f_flags, current_cred());
	path_put(&lower_path);
	if (IS_ERR(lower_file)) {
		err = PTR_ERR(lower_file);
		lower_file = amfs_lower_file(file);
		if (lower_file) {
			amfs_set_lower_file(file, NULL);
			fput(lower_file); /* fput calls dput for lower_dentry */
		}
	} else {
		amfs_set_lower_file(file, lower_file);
	}

	if (err)
		kfree(AMFS_F(file));
	else
		fsstack_copy_attr_all(inode, amfs_lower_inode(inode));
out_err:
	return err;
}

static int amfs_flush(struct file *file, fl_owner_t id)
{
	int err = 0;
	struct file *lower_file = NULL;

	lower_file = amfs_lower_file(file);
	if (lower_file && lower_file->f_op && lower_file->f_op->flush) {
		filemap_write_and_wait(file->f_mapping);
		err = lower_file->f_op->flush(lower_file, id);
	}

	return err;
}

/* release all lower object references & free the file info structure */
static int amfs_file_release(struct inode *inode, struct file *file)
{
	struct file *lower_file;

	lower_file = amfs_lower_file(file);
	if (lower_file) {
		amfs_set_lower_file(file, NULL);
		fput(lower_file);
	}

	kfree(AMFS_F(file));
	return 0;
}

static int amfs_fsync(struct file *file, loff_t start, loff_t end,
			int datasync)
{
	int err;
	struct file *lower_file;
	struct path lower_path;
	struct dentry *dentry = file->f_path.dentry;

	err = __generic_file_fsync(file, start, end, datasync);
	if (err)
		goto out;
	lower_file = amfs_lower_file(file);
	amfs_get_lower_path(dentry, &lower_path);
	err = vfs_fsync_range(lower_file, start, end, datasync);
	amfs_put_lower_path(dentry, &lower_path);
out:
	return err;
}

static int amfs_fasync(int fd, struct file *file, int flag)
{
	int err = 0;
	struct file *lower_file = NULL;

	lower_file = amfs_lower_file(file);
	if (lower_file->f_op && lower_file->f_op->fasync)
		err = lower_file->f_op->fasync(fd, lower_file, flag);

	return err;
}

static ssize_t amfs_aio_read(struct kiocb *iocb, const struct iovec *iov,
			       unsigned long nr_segs, loff_t pos)
{
	int err = -EINVAL;
	struct file *file, *lower_file;

	file = iocb->ki_filp;
	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->aio_read)
		goto out;
	/*
	 * It appears safe to rewrite this iocb, because in
	 * do_io_submit@fs/aio.c, iocb is a just copy from user.
	 */
	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->aio_read(iocb, iov, nr_segs, pos);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode atime as needed */
	if (err >= 0 || err == -EIOCBQUEUED)
		fsstack_copy_attr_atime(file->f_path.dentry->d_inode,
					file_inode(lower_file));
out:
	return err;
}

static ssize_t amfs_aio_write(struct kiocb *iocb, const struct iovec *iov,
				unsigned long nr_segs, loff_t pos)
{
	int err = -EINVAL;
	struct file *file, *lower_file;

	file = iocb->ki_filp;
	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->aio_write)
		goto out;
	/*
	 * It appears safe to rewrite this iocb, because in
	 * do_io_submit@fs/aio.c, iocb is a just copy from user.
	 */
	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->aio_write(iocb, iov, nr_segs, pos);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode times/sizes as needed */
	if (err >= 0 || err == -EIOCBQUEUED) {
		fsstack_copy_inode_size(file->f_path.dentry->d_inode,
					file_inode(lower_file));
		fsstack_copy_attr_times(file->f_path.dentry->d_inode,
					file_inode(lower_file));
	}
out:
	return err;
}

/*
 * Wrapfs cannot use generic_file_llseek as ->llseek, because it would
 * only set the offset of the upper file.  So we have to implement our
 * own method to set both the upper and lower file offsets
 * consistently.
 */
static loff_t amfs_file_llseek(struct file *file, loff_t offset, int whence)
{
	int err;
	struct file *lower_file;

	err = generic_file_llseek(file, offset, whence);
	if (err < 0)
		goto out;

	lower_file = amfs_lower_file(file);
	err = generic_file_llseek(lower_file, offset, whence);

out:
	return err;
}

/*
 * Wrapfs read_iter, redirect modified iocb to lower read_iter
 */
ssize_t
amfs_read_iter(struct kiocb *iocb, struct iov_iter *iter)
{
	int err;
	struct file *file = iocb->ki_filp, *lower_file;

	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->read_iter) {
		err = -EINVAL;
		goto out;
	}

	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->read_iter(iocb, iter);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode atime as needed */
	if (err >= 0 || err == -EIOCBQUEUED)
		fsstack_copy_attr_atime(file->f_path.dentry->d_inode,
					file_inode(lower_file));
out:
	return err;
}

/*
 * Wrapfs write_iter, redirect modified iocb to lower write_iter
 */
ssize_t
amfs_write_iter(struct kiocb *iocb, struct iov_iter *iter)
{
	int err;
	struct file *file = iocb->ki_filp, *lower_file;

	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->write_iter) {
		err = -EINVAL;
		goto out;
	}

	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->write_iter(iocb, iter);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode times/sizes as needed */
	if (err >= 0 || err == -EIOCBQUEUED) {
		fsstack_copy_inode_size(file->f_path.dentry->d_inode,
					file_inode(lower_file));
		fsstack_copy_attr_times(file->f_path.dentry->d_inode,
					file_inode(lower_file));
	}
out:
	return err;
}

const struct file_operations amfs_main_fops = {
	.llseek		= generic_file_llseek,
	.read		= amfs_read,
	.write		= amfs_write,
	.unlocked_ioctl	= amfs_unlocked_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl	= amfs_compat_ioctl,
#endif
	.mmap		= amfs_mmap,
	.open		= amfs_open,
	.flush		= amfs_flush,
	.release	= amfs_file_release,
	.fsync		= amfs_fsync,
	.fasync		= amfs_fasync,
	.aio_read	= amfs_aio_read,
	.aio_write	= amfs_aio_write,
	.read_iter	= amfs_read_iter,
	.write_iter	= amfs_write_iter,
};

/* trimmed directory options */
const struct file_operations amfs_dir_fops = {
	.llseek		= amfs_file_llseek,
	.read		= generic_read_dir,
	.iterate	= amfs_readdir,
	.unlocked_ioctl	= amfs_unlocked_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl	= amfs_compat_ioctl,
#endif
	.open		= amfs_open,
	.release	= amfs_file_release,
	.flush		= amfs_flush,
	.fsync		= amfs_fsync,
	.fasync		= amfs_fasync,
};
